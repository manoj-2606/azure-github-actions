==============================================================
  DAY 8 — CI/CD FOR TERRAFORM (AZURE DEVOPS)
  GOALS, OBJECTIVES & REAL-WORLD PURPOSE
==============================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHAT IS THE OVERALL OBJECTIVE?
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

The objective of Day 8 is to stop thinking like a solo developer
and start thinking like a production engineer.

Until now you've been doing:
  Engineer → terraform apply (DANGEROUS in teams)

After Day 8 you will do:
  Engineer → PR → Validate → Plan → Review → Approve → Apply → Audit

This shift in mindset is what separates a junior from a senior.
Knowing Terraform syntax is easy.
Knowing HOW to safely deliver infrastructure changes is the real skill.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  SPECIFIC GOALS — BY END OF DAY 8 YOU MUST HAVE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GOAL 1 — Repository Hygiene
  ✔ Fresh project folder with clean structure
  ✔ .gitignore ignoring .terraform/, *.tfstate, *.tfplan
  ✔ All .tf files pass terraform fmt -check
  ✔ All .tf files pass terraform validate
  WHY: Garbage in = garbage out. Clean repo = trustworthy team.

GOAL 2 — Remote State Connected
  ✔ Storage account stgtfstate2606 created in rg-tfstate
  ✔ Backend block configured in main.tf
  ✔ No local .tfstate files — everything in the cloud
  WHY: If state is on your laptop, nobody else can work with it.
       Remote state is the foundation of team-based Terraform.

GOAL 3 — Azure DevOps Pipeline Created
  ✔ azure-pipelines.yml with 4 distinct stages (not 2, not 3 — 4)
  ✔ Stage 1: Validate (fmt check + validate)
  ✔ Stage 2: Plan (runs on PR, publishes plan as artifact)
  ✔ Stage 3: Manual Approval Gate (no apply without this)
  ✔ Stage 4: Apply (runs ONLY on main branch after approval)
  WHY: This is what a production-grade pipeline looks like.
       Fewer stages = corners cut = risk introduced.

GOAL 4 — Automated PR Validation
  ✔ Every Pull Request triggers the pipeline automatically
  ✔ Pipeline fails if formatting is wrong
  ✔ Pipeline fails if validate fails
  ✔ No bad code can reach main without passing these checks
  WHY: Humans forget to run fmt and validate.
       Machines never forget. Automate the boring safety checks.

GOAL 5 — Plan as Artifact (Visible to Reviewers)
  ✔ terraform plan output is saved and published
  ✔ Reviewers can download and read the plan before approving
  ✔ No one approves a PR blindly
  WHY: An approval without reading the plan is not an approval.
       It's a rubber stamp. The artifact makes blind approvals impossible.

GOAL 6 — Manual Approval Before Apply
  ✔ ADO Environment "production-approval" created
  ✔ Approval check added to the environment
  ✔ Apply stage depends on approval — no bypass possible
  WHY: Automation is fast. Humans are the last line of defense.
       One approval gate prevents hundreds of potential incidents.

GOAL 7 — Apply Runs ONLY on Main
  ✔ Apply stage condition: only runs when branch = main
  ✔ Feature branches can never trigger apply
  ✔ Only merged, reviewed, approved code reaches Azure
  WHY: Feature branches are experiments.
       Main is truth. Only truth gets applied.

GOAL 8 — Main Branch is Protected
  ✔ Direct push to main is blocked via branch policy
  ✔ Every change MUST go through PR
  ✔ PR requires pipeline to pass before merge is allowed
  WHY: If anyone can push to main directly, your entire pipeline
       is just decoration. Branch protection makes it real.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  PURPOSE — WHY ARE YOU LEARNING THIS?
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PURPOSE 1 — Human Error is Inevitable
  Humans make mistakes. Tired engineers make worse mistakes.
  CI/CD pipelines are not about distrust — they are about
  removing the human from the dangerous parts of the process.
  The pipeline never runs apply at 2am by accident.
  The engineer might.

PURPOSE 2 — Teams Cannot Share a Laptop
  One engineer's local apply works fine.
  Two engineers doing local apply on the same infra = state conflicts,
  resource overwrites, and production incidents.
  A pipeline is the single, shared, authoritative way to apply.
  Everyone sees the same plan. Everyone follows the same process.

PURPOSE 3 — Audit Trail
  Every pipeline run in Azure DevOps creates a record:
    - WHO triggered it
    - WHAT the plan showed
    - WHO approved it
    - WHEN apply ran
    - WHAT the result was
  If something breaks in production, you have a complete history.
  Without a pipeline, you have nothing — just "I think someone ran apply."

PURPOSE 4 — Speed WITH Safety
  A common myth: "Pipelines slow us down."
  Reality: Bad pipelines slow you down. Good pipelines speed you up.
  When fmt, validate, and plan are automated:
    - Code review focuses on logic, not formatting
    - Reviewers see the exact impact before approving
    - Apply is instant after approval — no manual steps
  You ship faster because you catch problems earlier and cheaper.

PURPOSE 5 — This is the Industry Standard
  Every company using Terraform at scale uses this pattern:
    - HashiCorp calls it "The Ops Workflow"
    - Microsoft calls it "GitOps for Infrastructure"
    - DevOps teams call it "Infrastructure as Pull Requests"
  If you walk into an interview and describe this workflow,
  you demonstrate you've worked in or understand production environments.
  That is what makes you job-ready — not knowing resource blocks.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  REAL-WORLD SCENARIO — WHERE YOU WILL USE THIS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

SCENARIO A — Cloud/DevOps Engineer at a Product Company
  You own the Azure infrastructure for a SaaS product.
  When a developer needs a new storage account or AKS node pool,
  they raise a PR to the infrastructure repo.
  Your pipeline validates, plans, and shows the exact cost + impact.
  Your team lead approves. Pipeline applies. Done.
  No tickets. No manual work. No waiting.

SCENARIO B — Infrastructure Consultant at a Client Site
  Client has 5 engineers with Terraform access.
  Two of them have accidentally deleted prod databases in the past.
  You introduce branch protection + ADO pipeline.
  Now nobody can apply without a plan review and approval.
  Client sleeps better. You become the most valuable person in the room.

SCENARIO C — DevOps Engineer at a Bank or Enterprise
  Compliance requires proof that every infra change was reviewed.
  Auditors ask: "Who approved the storage account deletion on March 3rd?"
  With pipelines: you show them the ADO run, the plan artifact, the approval.
  Without pipelines: you have no answer. You fail the audit.

SCENARIO D — Startup Scaling Fast
  Month 1: 1 engineer, local apply is fine.
  Month 6: 8 engineers, 3 environments, 200 resources.
  Without pipelines: chaos — overwrites, conflicts, outages.
  With pipelines: structured, safe, scalable from day one.
  You become the person who set up the right foundation early.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHAT DOES SUCCESS LOOK LIKE AT END OF DAY 8?
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ✔ You push code → pipeline auto-triggers (you didn't run anything manually)
  ✔ Bad code → pipeline fails → main is protected (error never reaches Azure)
  ✔ Good code → plan artifact shows exactly what changes → reviewer reads it
  ✔ Reviewer approves → apply runs → Azure resource is created/updated
  ✔ You try to push directly to main → it gets rejected (branch policy works)
  ✔ You can explain to anyone WHY each stage exists and what it prevents

  If ALL of the above are true — you have completed Day 8.
  If even one is missing — go back and close the gap.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ONE-LINE SUMMARY OF EACH STAGE'S GOAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Stage 1 — Validate   : Catch broken or unformatted code before it wastes anyone's time
  Stage 2 — Plan       : Show exactly what will change so reviewers can make an informed decision
  Stage 3 — Approval   : Force a human to consciously say "yes, do this" before touching infra
  Stage 4 — Apply      : Execute the approved, reviewed, validated change — nothing more

==============================================================