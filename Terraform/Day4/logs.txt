PS C:\dev\git\azure-github-actions\Terraform\Day4\envs\dev> terraform apply
Acquiring state lock. This may take a few moments...
azurerm_resource_group.demo: Refreshing state... [id=/subscriptions/4985f681-bfb3-4e92-a131-b1e85dd4f934/resourceGroups/rg-demo-test]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # azurerm_resource_group.demo will be created
  + resource "azurerm_resource_group" "demo" {
      + id       = (known after apply)
      + location = "eastus"
      + name     = "rg-demo-test"
    }

Plan: 1 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

Here’s the blunt truth

When you use a remote backend:

Terraform completely stops trusting your local .tfstate.

Local file becomes:

cache

temp artifact

disposable

The real source of truth becomes:

Azure Blob → dev.tfstate / stage.tfstate

That blob is the database.

Everything else is noise.

What actually happens under the hood

When you run:

terraform plan


Terraform does this:

Connect to backend (Azure)

Download remote state

Load into memory

Run plan

Optionally write updated state back

It does NOT:

read your local .tfstate first

fall back to local

merge anything

Local is ignored.